---
alwaysApply: false
---
# Правила разработки для Code Ассистента

Полное техническое видение проекта: [@docs/vision.md](vision.md)

## Основные принципы

### KISS (Keep It Simple, Stupid)
- Простые решения вместо сложных
- Без преждевременной оптимизации
- Код должен быть понятен с первого взгляда
- Только необходимый функционал для MVP

### ООП и структура файлов
- **Один класс = один файл = одна ответственность**
- Плоская структура без глубокой вложенности
- Имена файлов соответствуют классам: `llm_client.py` → класс `LLMClient`
- Никаких "божественных объектов"

### Читаемость
- Говорящие имена переменных и функций
- Короткие функции (до 20-30 строк)
- Минимум вложенности

### Типизация
- Type hints обязательны для всех функций и методов
- Используем Pydantic для моделей данных и конфигурации

### Документирование
- Docstring для всех публичных методов и функций
- Описание параметров, возвращаемых значений и исключений

### Асинхронность
- Используем async/await для всех I/O операций
- Не блокируем event loop

### Логирование
- Логируем все ключевые события
- Уровни: DEBUG, INFO, WARNING, ERROR
- Используем встроенный модуль `logging`
- Не логируем секреты (токены, ключи)

## Технологический стек

### Обязательные библиотеки
- Python 3.11+
- aiogram 3.x (Telegram Bot API)
- openai (для OpenRouter API)
- pydantic (валидация)
- python-dotenv (конфигурация)

### Минимализм зависимостей
- Только необходимые библиотеки
- Используем встроенные модули где возможно (`logging`, `argparse`, `json`)
- Без "а вдруг пригодится"

## Работа с UV в Windows PowerShell

### ⚠️ Важно для Windows!

**Все команды обращенные к `uv` необходимо выполнять через полный путь:**

```powershell
& "$env:USERPROFILE\.local\bin\uv.exe"
```

### Почему так?
- В PowerShell команда `uv` может не распознаваться напрямую
- Полный путь через `$env:USERPROFILE` гарантирует работу
- Оператор `&` используется для вызова исполняемых файлов в PowerShell

### Примеры команд:

**Запуск бота:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" run python -m src.main --env-file .env.development
```

**Установка/синхронизация зависимостей:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" sync
```

**Добавление новой библиотеки:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" add <package-name>
```

**Запуск скриптов:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" run python test_script.py
```

**Проверка импортов:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" run python -c "from src.bot import Bot; print('OK')"
```

## Структура кода

### Компоненты (примеры из vision.md)
- `bot.py` → класс `Bot`
- `llm_client.py` → класс `LLMClient`
- `message_handler.py` → класс `MessageHandler`
- `storage.py` → класс `Storage`
- `config.py` → класс `Config`

### Организация
- Все исходники в `src/`
- Данные в `data/`
- Логи в `logs/`
- Документация в `docs/`

## Обработка ошибок

- Обрабатываем все исключения явно
- Используем retry механизм для внешних API
- Логируем полный контекст ошибок
- Возвращаем понятные сообщения пользователю

## Конфигурация

- Все настройки в `.env` файле
- Валидация через Pydantic
- Без секретов в коде и git
- Поддержка `--env-file` аргумента

## Качество кода

### Форматирование

**Инструмент: Ruff**
- Максимальная длина строки: 100 символов
- Автоматическое форматирование через `make format`
- Сортировка импортов
- Удаление неиспользуемых импортов

### Линтинг

**Инструмент: Ruff**
- Проверка на PEP 8 нарушения
- Поиск потенциальных багов
- Выявление неиспользуемых переменных
- Проверка сложности кода
- Запуск через `make lint`

**Правила линтера:**
- E, F - базовые ошибки и синтаксис
- I - импорты
- N - именование
- W - предупреждения
- UP - upgrade синтаксис (modern Python)
- B - потенциальные баги
- A - shadowing built-ins
- C4 - comprehensions
- DTZ - datetime
- T20 - print statements
- RET - return statements
- SIM - simplifications
- ARG - unused arguments

### Статическая проверка типов

**Инструмент: Mypy**
- Строгий режим (`strict = true`)
- Проверка всех типов
- Нет `Any` без необходимости
- Проверка через `make lint`

### Pre-commit hooks

**Автоматическая проверка перед коммитом:**
- Форматирование кода (ruff format)
- Линтинг (ruff check)
- Проверка типов (mypy)
- Установка: `make pre-commit-install`

## Тестирование

### Обязательные требования

- Unit-тесты для всей критической логики
- Минимальное покрытие: **70%** для Storage и LLMClient
- Async тесты через pytest-asyncio
- Фикстуры в `tests/conftest.py`

### Структура тестов

```
tests/
├── __init__.py
├── conftest.py          # Общие фикстуры
├── test_storage.py      # Тесты Storage
├── test_llm_client.py   # Тесты LLMClient
└── test_handlers.py     # Тесты handlers (после рефакторинга)
```

### Запуск тестов

```powershell
# С coverage отчетом
make test

# Быстрый запуск без coverage
make test-fast

# Конкретный файл
& "$env:USERPROFILE\.local\bin\uv.exe" run pytest tests/test_storage.py -v
```

### Что тестируем

✅ **Обязательно:**
- Storage: загрузка/сохранение, лимиты, промпты
- LLMClient: успешные запросы, retry, ошибки
- Utils: разбивка сообщений, форматирование ошибок

✅ **Желательно:**
- Handlers: обработка команд
- Config: валидация настроек

❌ **Не тестируем:**
- Внешние API (используем моки)
- Telegram Bot API (используем моки)

## Best Practices Python

### 1. Async/Await правильно

✅ **Правильно:**
```python
# Нативный async I/O
import aiofiles

async def save_data(path: Path, data: dict) -> None:
    async with aiofiles.open(path, "w") as f:
        await f.write(json.dumps(data))
```

❌ **Неправильно:**
```python
# Блокирующий I/O через run_in_executor
def _save_sync(path, data):
    with open(path, "w") as f:
        json.dump(data, f)

async def save_data(path, data):
    loop = asyncio.get_event_loop()
    await loop.run_in_executor(None, self._save_sync, path, data)
```

### 2. DRY (Don't Repeat Yourself)

Избегайте повторяющегося кода:
- Вынесите общую логику в функции
- Используйте декораторы для повторяющихся паттернов
- Создавайте утилиты для часто используемых операций

### 3. SOLID принципы

**S - Single Responsibility:**
- Один класс/функция = одна задача
- Пример: `Storage` только для работы с файлами, `LLMClient` только для LLM API

**O - Open/Closed:**
- Открыт для расширения, закрыт для модификации
- Используйте наследование и композицию

**L - Liskov Substitution:**
- Подклассы должны быть заменяемы на базовые классы
- Соблюдайте контракты интерфейсов

**I - Interface Segregation:**
- Маленькие специфичные интерфейсы вместо больших
- Клиент не должен зависеть от ненужных методов

**D - Dependency Inversion:**
- Зависимость от абстракций, а не от конкретики
- Передавайте зависимости через параметры

### 4. Error Handling

```python
# Специфичные исключения
class LLMAPIError(Exception):
    """Исключение для ошибок LLM API."""
    pass

# Явная обработка
try:
    response = await llm_client.generate_response(messages, user_id)
except LLMAPIError as e:
    logger.error(f"LLM API error: {e}")
    await message.answer("⚠️ Ошибка при обращении к LLM")
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    await message.answer("⚠️ Неожиданная ошибка")
```

### 5. Контекстные менеджеры

Всегда используйте context managers для ресурсов:

```python
# Файлы
async with aiofiles.open(path, "r") as f:
    content = await f.read()

# HTTP сессии
async with aiohttp.ClientSession() as session:
    async with session.get(url) as response:
        data = await response.json()
```

### 6. List/Dict Comprehensions

Используйте comprehensions вместо циклов где возможно:

```python
# ✅ Правильно
api_messages = [
    {"role": msg["role"], "content": msg["content"]}
    for msg in messages
]

# ❌ Неправильно
api_messages = []
for msg in messages:
    api_messages.append({"role": msg["role"], "content": msg["content"]})
```

### 7. Современный Python синтаксис

```python
# Type hints с new-style syntax (Python 3.10+)
def process(items: list[str]) -> dict[str, int]:
    ...

# Pattern matching (Python 3.10+)
match status:
    case "success":
        handle_success()
    case "error":
        handle_error()

# Walrus operator
if (value := get_value()) is not None:
    process(value)
```

## Что НЕ делать

- ❌ Оверинжиниринг и избыточная абстракция
- ❌ Классы с множественной ответственностью
- ❌ Глубокая вложенность директорий
- ❌ Синхронный код для I/O операций
- ❌ Неявная обработка ошибок
- ❌ Код без type hints
- ❌ Публичные методы без docstrings
- ❌ Коммиты без прохождения линтера
- ❌ Код без тестов для критической логики
- ❌ Использование `print()` вместо `logging`
- ❌ Игнорирование предупреждений mypy
- ❌ Захардкоженные значения вместо конфигурации

## Примеры

### ✅ Правильно
```python
class LLMClient:
    """Клиент для работы с LLM через OpenRouter API."""
    
    async def generate_response(
        self, 
        messages: list[dict[str, str]], 
        user_id: int
    ) -> str:
        """
        Генерирует ответ LLM на основе истории сообщений.
        
        Args:
            messages: История диалога в формате OpenAI
            user_id: ID пользователя для логирования
            
        Returns:
            Текст ответа от LLM
            
        Raises:
            LLMAPIError: При ошибке API после всех retry попыток
        """
        # Реализация
```

### ❌ Неправильно
```python
class Bot:
    # Нет docstring, нет type hints, множественная ответственность
    def process(self, msg):
        # Обработка сообщения, работа с LLM, сохранение в Storage
        # всё в одном методе на 200 строк
```

## Для подробностей

Полное техническое описание архитектуры, компонентов, сценариев работы и конфигурации смотри в [@docs/vision.md](vision.md).

