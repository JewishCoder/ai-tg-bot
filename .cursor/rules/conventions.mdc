---
alwaysApply: true
---
# Правила разработки для Code Ассистента

Полное техническое видение проекта: [@docs/vision.md](vision.md)

## Основные принципы

### KISS (Keep It Simple, Stupid)
- Простые решения вместо сложных
- Без преждевременной оптимизации
- Код должен быть понятен с первого взгляда
- Только необходимый функционал для MVP

### ООП и структура файлов
- **Один класс = один файл = одна ответственность**
- Плоская структура без глубокой вложенности
- Имена файлов соответствуют классам: `llm_client.py` → класс `LLMClient`
- Никаких "божественных объектов"

### Читаемость
- Говорящие имена переменных и функций
- Короткие функции (до 20-30 строк)
- Минимум вложенности

### Типизация
- Type hints обязательны для всех функций и методов
- Используем Pydantic для моделей данных и конфигурации

### Документирование
- Docstring для всех публичных методов и функций
- Описание параметров, возвращаемых значений и исключений

### Асинхронность
- Используем async/await для всех I/O операций
- Не блокируем event loop

### Логирование
- Логируем все ключевые события
- Уровни: DEBUG, INFO, WARNING, ERROR
- Используем встроенный модуль `logging`
- Не логируем секреты (токены, ключи)

## Технологический стек

### Обязательные библиотеки
- Python 3.11+
- aiogram 3.x (Telegram Bot API)
- openai (для OpenRouter API)
- pydantic (валидация)
- pydantic-settings (конфигурация из .env)
- python-dotenv (загрузка переменных окружения)

### Database и ORM
- PostgreSQL - основное хранилище данных
- SQLAlchemy 2.0 (async) - ORM для работы с PostgreSQL
- asyncpg - асинхронный драйвер PostgreSQL
- Alembic - система миграций базы данных
- aiofiles - асинхронная работа с файлами (если нужно)

### Минимализм зависимостей
- Только необходимые библиотеки
- Используем встроенные модули где возможно (`logging`, `argparse`, `json`)
- Без "а вдруг пригодится"

## Работа с UV в Windows PowerShell

### ⚠️ Важно для Windows!

**Все команды обращенные к `uv` необходимо выполнять через полный путь:**

```powershell
& "$env:USERPROFILE\.local\bin\uv.exe"
```

### Почему так?
- В PowerShell команда `uv` может не распознаваться напрямую
- Полный путь через `$env:USERPROFILE` гарантирует работу
- Оператор `&` используется для вызова исполняемых файлов в PowerShell

### Примеры команд:

**Запуск бота:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" run python -m src.main --env-file .env.development
```

**Установка/синхронизация зависимостей:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" sync
```

**Добавление новой библиотеки:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" add <package-name>
```

**Запуск скриптов:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" run python test_script.py
```

**Проверка импортов:**
```powershell
& "$env:USERPROFILE\.local\bin\uv.exe" run python -c "from src.bot import Bot; print('OK')"
```

## Структура кода

### Компоненты (примеры из vision.md)
- `bot.py` → класс `Bot`
- `llm_client.py` → класс `LLMClient`
- `storage.py` → класс `Storage` (работа с PostgreSQL)
- `database.py` → управление подключением к БД и сессиями
- `models.py` → SQLAlchemy модели (User, Message, UserSettings)
- `config.py` → класс `Config`
- `handlers/commands.py` → обработчики команд (/start, /help, /role, /status, /reset)
- `handlers/messages.py` → обработчик текстовых сообщений
- `utils/message_splitter.py` → разбивка длинных сообщений
- `utils/error_formatter.py` → форматирование ошибок

### Организация
- Все исходники в `src/`
- Данные в `data/`
- Логи в `logs/`
- Документация в `docs/`
- Миграции БД в `alembic/versions/`

## Обработка ошибок

- Обрабатываем все исключения явно
- Используем retry механизм для внешних API
- Логируем полный контекст ошибок
- Возвращаем понятные сообщения пользователю

## Конфигурация

- Все настройки в `.env` файле
- Валидация через Pydantic
- Без секретов в коде и git
- Поддержка `--env-file` аргумента

## Database миграции

### Alembic - система миграций

Все изменения схемы БД управляются через Alembic миграции.

### Команды миграций (через Makefile)

**Применить все миграции:**
```powershell
make db-migrate
```

**Откатить последнюю миграцию:**
```powershell
make db-rollback
```

**Создать новую миграцию:**
```powershell
make db-revision message="Add new column to users"
```

**Показать текущую версию БД:**
```powershell
make db-current
```

### Команды через UV напрямую:

```powershell
# Применить миграции
& "$env:USERPROFILE\.local\bin\uv.exe" run alembic upgrade head

# Создать миграцию
& "$env:USERPROFILE\.local\bin\uv.exe" run alembic revision --autogenerate -m "your message"

# Откатить
& "$env:USERPROFILE\.local\bin\uv.exe" run alembic downgrade -1
```

### Принципы работы с БД

**Async SQLAlchemy 2.0:**
- Все операции с БД через async/await
- Используем AsyncSession для всех запросов
- Контекстный менеджер для автоматического закрытия сессий

**Soft delete стратегия:**
- Сообщения не удаляются физически из БД
- При "удалении" устанавливается поле `deleted_at`
- Активные сообщения имеют `deleted_at = NULL`
- Запросы всегда фильтруют по `deleted_at.is_(None)`

**Timezone-aware timestamps:**
- Все datetime поля с timezone (TIMESTAMP WITH TIME ZONE)
- Используем `func.now()` для автоматических timestamp
- Поле `updated_at` обновляется автоматически через `onupdate=func.now()`

**Управляемые лимиты:**
- Каждый пользователь имеет свой лимит истории в `user_settings.max_history_messages`
- Значение по умолчанию берется из конфигурации
- При превышении лимита старые сообщения помечаются как удаленные (soft delete)

### Модели данных

**User** - информация о пользователях:
- `id` (BigInteger) - Telegram user ID
- `created_at`, `updated_at` - timestamps с timezone

**Message** - история сообщений с soft delete:
- `id` (UUID) - уникальный идентификатор
- `user_id` - связь с User
- `role` (user/assistant/system) - роль сообщения
- `content` - текст сообщения
- `content_length` - длина сообщения
- `created_at` - когда создано
- `deleted_at` - когда помечено удаленным (NULL для активных)

**UserSettings** - настройки пользователей:
- `user_id` - связь с User (primary key)
- `max_history_messages` - лимит истории для пользователя
- `system_prompt` - кастомный системный промпт
- `created_at`, `updated_at` - timestamps

## Качество кода

### Форматирование

**Инструмент: Ruff**
- Максимальная длина строки: 100 символов
- Автоматическое форматирование через `make format`
- Сортировка импортов
- Удаление неиспользуемых импортов

### Линтинг

**Инструмент: Ruff**
- Проверка на PEP 8 нарушения
- Поиск потенциальных багов
- Выявление неиспользуемых переменных
- Проверка сложности кода
- Запуск через `make lint`

**Правила линтера:**
- E, F - базовые ошибки и синтаксис
- I - импорты
- N - именование
- W - предупреждения
- UP - upgrade синтаксис (modern Python)
- B - потенциальные баги
- A - shadowing built-ins
- C4 - comprehensions
- DTZ - datetime
- T20 - print statements
- RET - return statements
- SIM - simplifications
- ARG - unused arguments

### Статическая проверка типов

**Инструмент: Mypy**
- Строгий режим (`strict = true`)
- Проверка всех типов
- Нет `Any` без необходимости
- Проверка через `make lint`

### Pre-commit hooks

**Автоматическая проверка перед коммитом:**
- Форматирование кода (ruff format)
- Линтинг (ruff check)
- Проверка типов (mypy)
- Установка: `make pre-commit-install`

## Тестирование

### Обязательные требования

- Unit-тесты для всей критической логики
- Минимальное покрытие: **70%** для Storage и LLMClient
- Async тесты через pytest-asyncio
- Фикстуры в `tests/conftest.py`

### Структура тестов

```
tests/
├── __init__.py
├── conftest.py          # Общие фикстуры
├── test_storage.py      # Тесты Storage
├── test_llm_client.py   # Тесты LLMClient
└── test_handlers.py     # Тесты handlers (после рефакторинга)
```

### Запуск тестов

```powershell
# С coverage отчетом
make test

# Быстрый запуск без coverage
make test-fast

# Конкретный файл
& "$env:USERPROFILE\.local\bin\uv.exe" run pytest tests/test_storage.py -v
```

### Что тестируем

✅ **Обязательно:**
- Storage: загрузка/сохранение, лимиты, промпты
- LLMClient: успешные запросы, retry, ошибки
- Utils: разбивка сообщений, форматирование ошибок

✅ **Желательно:**
- Handlers: обработка команд
- Config: валидация настроек

❌ **Не тестируем:**
- Внешние API (используем моки)
- Telegram Bot API (используем моки)

## Best Practices Python

### 1. Async/Await правильно

✅ **Правильно:**
```python
# Async SQLAlchemy для работы с БД
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from src.models import Message

async def get_user_messages(
    session: AsyncSession, 
    user_id: int
) -> list[Message]:
    """Получить активные сообщения пользователя."""
    result = await session.execute(
        select(Message)
        .where(Message.user_id == user_id)
        .where(Message.deleted_at.is_(None))  # Soft delete
        .order_by(Message.created_at)
    )
    return list(result.scalars().all())
```

❌ **Неправильно:**
```python
# Блокирующий sync SQLAlchemy
from sqlalchemy.orm import Session

def get_user_messages(session: Session, user_id: int):
    # Блокирует event loop!
    return session.query(Message).filter_by(user_id=user_id).all()
```

### 2. DRY (Don't Repeat Yourself)

Избегайте повторяющегося кода:
- Вынесите общую логику в функции
- Используйте декораторы для повторяющихся паттернов
- Создавайте утилиты для часто используемых операций

### 3. SOLID принципы

**S - Single Responsibility:**
- Один класс/функция = одна задача
- Пример: `Storage` только для работы с PostgreSQL, `LLMClient` только для LLM API, `Database` только для управления подключениями

**O - Open/Closed:**
- Открыт для расширения, закрыт для модификации
- Используйте наследование и композицию

**L - Liskov Substitution:**
- Подклассы должны быть заменяемы на базовые классы
- Соблюдайте контракты интерфейсов

**I - Interface Segregation:**
- Маленькие специфичные интерфейсы вместо больших
- Клиент не должен зависеть от ненужных методов

**D - Dependency Inversion:**
- Зависимость от абстракций, а не от конкретики
- Передавайте зависимости через параметры

### 4. Error Handling

```python
# Специфичные исключения
class LLMAPIError(Exception):
    """Исключение для ошибок LLM API."""
    pass

# Явная обработка
try:
    response = await llm_client.generate_response(messages, user_id)
except LLMAPIError as e:
    logger.error(f"LLM API error: {e}")
    await message.answer("⚠️ Ошибка при обращении к LLM")
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    await message.answer("⚠️ Неожиданная ошибка")
```

### 5. Контекстные менеджеры

Всегда используйте context managers для ресурсов:

```python
# Database сессии (async SQLAlchemy)
from src.database import get_async_session

async with get_async_session() as session:
    result = await session.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()

# Файлы (если нужно)
async with aiofiles.open(path, "r") as f:
    content = await f.read()

# HTTP сессии
async with aiohttp.ClientSession() as session:
    async with session.get(url) as response:
        data = await response.json()
```

### 6. List/Dict Comprehensions

Используйте comprehensions вместо циклов где возможно:

```python
# ✅ Правильно
api_messages = [
    {"role": msg["role"], "content": msg["content"]}
    for msg in messages
]

# ❌ Неправильно
api_messages = []
for msg in messages:
    api_messages.append({"role": msg["role"], "content": msg["content"]})
```

### 7. Современный Python синтаксис

```python
# Type hints с new-style syntax (Python 3.10+)
def process(items: list[str]) -> dict[str, int]:
    ...

# Pattern matching (Python 3.10+)
match status:
    case "success":
        handle_success()
    case "error":
        handle_error()

# Walrus operator
if (value := get_value()) is not None:
    process(value)
```

## Что НЕ делать

- ❌ Оверинжиниринг и избыточная абстракция
- ❌ Классы с множественной ответственностью
- ❌ Глубокая вложенность директорий
- ❌ Синхронный код для I/O операций (файлы, БД, HTTP)
- ❌ Sync SQLAlchemy вместо async (блокирует event loop!)
- ❌ Физическое удаление данных (используем soft delete)
- ❌ Неявная обработка ошибок
- ❌ Код без type hints
- ❌ Публичные методы без docstrings
- ❌ Коммиты без прохождения линтера
- ❌ Код без тестов для критической логики
- ❌ Использование `print()` вместо `logging`
- ❌ Игнорирование предупреждений mypy
- ❌ Захардкоженные значения вместо конфигурации
- ❌ Миграции БД без Alembic (прямое изменение схемы)

## Примеры

### ✅ Правильно - LLM Client
```python
class LLMClient:
    """Клиент для работы с LLM через OpenRouter API."""
    
    async def generate_response(
        self, 
        messages: list[dict[str, str]], 
        user_id: int
    ) -> str:
        """
        Генерирует ответ LLM на основе истории сообщений.
        
        Args:
            messages: История диалога в формате OpenAI
            user_id: ID пользователя для логирования
            
        Returns:
            Текст ответа от LLM
            
        Raises:
            LLMAPIError: При ошибке API после всех retry попыток
        """
        # Реализация
```

### ✅ Правильно - Storage с soft delete
```python
class Storage:
    """Хранилище диалогов в PostgreSQL с soft delete."""
    
    async def delete_old_messages(
        self,
        session: AsyncSession,
        user_id: int,
        keep_count: int
    ) -> int:
        """
        Soft delete старых сообщений, оставляя только последние keep_count.
        
        Args:
            session: Async SQLAlchemy сессия
            user_id: ID пользователя
            keep_count: Сколько последних сообщений оставить
            
        Returns:
            Количество помеченных как удаленные сообщений
        """
        # Soft delete через установку deleted_at
        old_messages = await session.execute(
            select(Message)
            .where(Message.user_id == user_id)
            .where(Message.deleted_at.is_(None))
            .order_by(Message.created_at.desc())
            .offset(keep_count)
        )
        
        deleted_count = 0
        for msg in old_messages.scalars():
            msg.deleted_at = func.now()
            deleted_count += 1
            
        await session.commit()
        return deleted_count
```

### ❌ Неправильно
```python
class Bot:
    # Нет docstring, нет type hints, множественная ответственность
    def process(self, msg):
        # Обработка сообщения, работа с LLM, сохранение в Storage
        # всё в одном методе на 200 строк
        
        # Физическое удаление (❌)
        session.delete(message)
        
        # Sync SQLAlchemy (❌)
        messages = session.query(Message).all()
```

## Для подробностей

Полное техническое описание архитектуры, компонентов, сценариев работы и конфигурации смотри в [@docs/vision.md](vision.md).

